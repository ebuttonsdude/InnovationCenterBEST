#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Motor,  port2,           RightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           Arm,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,            ,             tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           LeftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           Claw,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           Turntable,     tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool boolSlowButton = false;
bool clawclose=false;
bool clawopen=false;
bool clawc=false;
bool hum = false;

//Play the digdug theme :)
task digdug()
{
	while(1)
	{
		//        225 = Tempo
		//          5 = Default octave
		//    Quarter = Default note length
		//        10% = Break between notes
		//
		playTone(  523,   12); wait1Msec( 133);  // Note(C, Duration(Eighth))
		playTone(  783,   12); wait1Msec( 133);  // Note(G, Duration(Eighth))
		playTone(  523,   12); wait1Msec( 133);  // Note(C, Duration(Eighth))
		playTone(  783,   12); wait1Msec( 133);  // Note(G, Duration(Eighth))
		playTone(  493,   12); wait1Msec( 133);  // Note(B4, Duration(Eighth))
		playTone(  783,   12); wait1Msec( 133);  // Note(G, Duration(Eighth))
		playTone(  493,   12); wait1Msec( 133);  // Note(B4, Duration(Eighth))
		playTone(  783,   12); wait1Msec( 133);  // Note(G, Duration(Eighth))
		playTone(  466,   12); wait1Msec( 133);  // Note(A#4, Duration(Eighth))
		playTone(  783,   12); wait1Msec( 133);  // Note(G, Duration(Eighth))
		playTone(  466,   12); wait1Msec( 133);  // Note(A#4, Duration(Eighth))
		playTone(  783,   12); wait1Msec( 133);  // Note(G, Duration(Eighth))
		playTone(  440,   12); wait1Msec( 133);  // Note(A4, Duration(Eighth))
		playTone(  783,   12); wait1Msec( 133);  // Note(G, Duration(Eighth))
		playTone(  440,   12); wait1Msec( 133);  // Note(A4, Duration(Eighth))
		playTone(  783,   12); wait1Msec( 133);  // Note(G, Duration(Eighth))
		playTone(  415,   12); wait1Msec( 133);  // Note(G#4, Duration(Eighth))
		playTone(  698,   12); wait1Msec( 133);  // Note(F, Duration(Eighth))
		playTone(  415,   12); wait1Msec( 133);  // Note(G#4, Duration(Eighth))
		playTone(  698,   12); wait1Msec( 133);  // Note(F, Duration(Eighth))
		playTone(  415,   12); wait1Msec( 133);  // Note(G#4, Duration(Eighth))
		playTone(  698,   12); wait1Msec( 133);  // Note(F, Duration(Eighth))
		playTone(  415,   12); wait1Msec( 133);  // Note(G#4, Duration(Eighth))
		playTone(  698,   12); wait1Msec( 133);  // Note(F, Duration(Eighth))
		playTone(  391,   12); wait1Msec( 133);  // Note(G4, Duration(Eighth))
		playTone(  698,   12); wait1Msec( 133);  // Note(F, Duration(Eighth))
		playTone(  391,   12); wait1Msec( 133);  // Note(G4, Duration(Eighth))
		playTone(  698,   12); wait1Msec( 133);  // Note(F, Duration(Eighth))
		playTone(  440,   12); wait1Msec( 133);  // Note(A4, Duration(Eighth))
		playTone(  698,   12); wait1Msec( 133);  // Note(F, Duration(Eighth))
		playTone(  493,   12); wait1Msec( 133);  // Note(B4, Duration(Eighth))
	}
}

void armprogram()
{
	if (vexRT[Btn6U] == 1 )
	{
		motor[Arm]=127;
		hum = true;
	}
	else
	{
		motor[Arm]=0;
	}
	if (vexRT[Btn6D] == 1 )
	{
		hum = true;
		motor[Arm]=-127;
	}
	else
	{
		motor[Arm]=0;
	}
}

void get_controls()
{
	if (vexRT[Btn6D] == 1)
	{
		clawclose = true;
		clawopen=false;
	}
	else
	{
		clawclose = false;
		clawopen = true;
	}
	if (vexRT[Btn6U] == 1)
	{
		clawopen = true;
	}
	else
	{
		clawopen = false;
	}
	if (vexRT[Btn7L] == 1)
	{
		clawc = true;
	}
	else
	{
		clawc = false;
	}
	if (clawc == false)
	{
		motor[Turntable]=-127;
	}
	else
	{
		motor[Turntable]=127;
	}
	if (clawopen == true)
	{
		motor[Claw]=127;
		clawclose=false;
	}
	else if (clawclose == true)
	{
		motor[Claw]=-127;
		clawopen=false;
	}
	else
	{
		motor[Claw]=0;
	}
}

//Slow down the controls if a button is pressed
void SlowButton()
{
	if(vexRT(Btn8D) == true)
	{
		boolSlowButton = true;
	}
	if(vexRT(Btn8U) == true)
	{
		boolSlowButton = false;
	}
}

//this code is also called tank drive. One joystick controls 1 side of the robot base.
void StandardDrive()
{
	if(boolSlowButton == true)
	{
		motor[RightMotor] = vexRT(Ch2)/3;
		motor[LeftMotor] = vexRT(Ch3)/3;
	}
	else
	{
		motor[RightMotor] = vexRT(Ch2);
		motor[LeftMotor] = vexRT(Ch3);
	}

}

//we dont need this code, but ill keep it here so if it's needed its here :)
// This code has 1 stick for up and down, as well as turning.
/*void ArcadeDrive1Stick()
{
motor[LeftMotor] = (vexRT[Ch2] + vexRT[Ch1])/2; // (y + x)/2
motor[RightMotor] = (vexRT[Ch2] - vexRT[Ch1])/2; // (y - x)/2
}
*/

// This code has 1 stick for up and down, and the other for turning.
void ArcadeDrive2Stick()
{
	if(boolSlowButton == true)
	{
		motor[LeftMotor] = (vexRT[Ch3] + vexRT[Ch1])/3; // (y + x)/3
		motor[RightMotor] = (vexRT[Ch3] - vexRT[Ch1])/3; // (y - x)/3
	}
	else
	{
		motor[LeftMotor] = (vexRT[Ch3] + vexRT[Ch1]); // (y + x)
		motor[RightMotor] = (vexRT[Ch3] - vexRT[Ch1]); // (y - x)
	}
}

// if pot < 2047, run arcade controls, else run standard drive (tank controls)
void Base()
{
	if(SensorValue[pot] < 2047)
	{
		ArcadeDrive2Stick();
	}
	else
	{
		StandardDrive();
	}
}

//instructions: if the potentiometer is less than halfway, use arcade drive. If it's over halfway, use tank drive.

task main()
{
	startTask(digdug);
	bool boolReitzigSanity = false; //this is always false, as Mr. Reitzig is insane :p
	while(boolReitzigSanity == false) // run forever
	{
		SlowButton();
		Base();
		get_controls();
		armprogram();
	}
}
